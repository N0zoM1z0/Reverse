# Lab11-02
先用strings.exe查看字符串
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120090607428-2004990009.png)

这里注意到Reg...说明这个dll对注册表进行了操作
注意到 .ini 文件 strings查看
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120090741523-1514774233.png)

这里应该是类似key或者hash值check的东西
大致了解后IDA打开
DllMain:
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120091847454-1022895770.png)

这里读取了.ini的内容后作了一个计算
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120092106533-938595313.png)

目前还不知道作用 感觉重点在后面的sub_100014B6函数
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120092956632-299780514.png)
![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120093023489-691589234.png)

这里印证了我们的猜测 这个函数确实send了sth 想要知道到底send了什么 
跟进sub_100012A3
进行了一系列GetModule LoadLibrary GetProcess 操作
继续跟进 sub_10001203
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120093652764-987073343.png)

感觉像是对内存进行了修改
返回去看看sub_100012A3传的第三个参数是一个函数的地址 查看sub_1000113D
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120094020973-606974291.png)

搜索知道`RCPT TO`是收件人地址的意思 那么这里应该就是send的核心操作了

注意到byte_100034A0是之前main中读取.ini cal后的值 只是这里调用的dword_10003484实在不知道是什么 交叉引用也看不到哪里进行了赋值

看到函数列表还有一个可疑的installer
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120094834605-139531107.png)

这里代码简单 就是为这个xxx.dll在注册表中setvalue 同时将当前文件的内容copy到这个新建立的dll里面
查看valuename: `AppInit_DLLs`

https://www.cnblogs.com/analyzer/articles/1726300.html

这个键值十分特殊: 对于任何使用到User32.dll的PE文件都会读取这个地方 而且会按照约定规范将这个键值下指向的DLL文件加载(LoadLibrary)
这么一看这个 spoolxxx.dll就是一个拦截型的dll了(了解知道这叫一种`system-wide hook`)

`因为进程内部的DLL是共享整个进程空间的，因此意味着进程里面的DLL是可以控制整个进程的行为的`

到处找都找不到哪里调用了这个installer函数 那么猜测就是安装这个dll的时候会自动调用

查了查发现
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231120100300583-447521252.png)

猜测每个dll都可以自己实现一个installer(类似继承重写) 自定义安装(注册)规则

补: 关于前面send的Destination 用python解出来乱码 但是C写写就能得到: `billy@malwareanalysisbookcom`(~~后来发现写python的时候没有&0xff~~)

所以这就是send的接收方

大致流程就很清楚了:

安装dll -> 修改注册表(AppInit_DLLs)  添加`\spoolvxx32.dll` -> when 系统PE文件调用user32.dll -> 加载DllMain -> hook wsock.dll -> send to xxx


# Lab11-03
两个文件 一个exe一个dll
strings.exe查看 exe
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231121082532169-1939106505.png)

注意到这里出现了`net start cisvc`
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231121082708187-500430107.png)

同时还挂载了一些dll

用CFF大致查看了下PE头 IDA打开 静态分析

> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231121083725166-612268752.png)

main主要就将Lab11-03.dll复制到System32下的一个dll 然后启动cisvc

sub_401070暂且看不懂 先看看dll到底干了什么 IDA打开

> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231121084444639-1536326028.png)

这里创建的kernel64x.dll应该是伪造的一个dll 创建文件后进行了SetFilePointer 那么肯定进行了某些写入

关键点就在于sub_10001380

> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231121084734105-1634334607.png)

同时在sub_10001030函数中发现了`GetAsyncKeyState`
> ![image](https://img2023.cnblogs.com/blog/3092507/202311/3092507-20231121084818652-500856809.png)

所以这里记录了鼠标状态 那么if里面的操作就是将鼠标状态写入文件了 同时还记录了`<shift>`键

能猜测出这个恶意代码想要记录用户的鼠标(键盘)数据

现在还有几个点未解决:
- 不进行注册表注册?
- cisvc的作用?
- 将窃取结果write到哪个文件?    其实用了mapvieoffile建立映射后不需要write 任何修改都会被记录
- 开机自启动?还是说有其他的触发条件?(比如调用某个dll时)   ():cisvc开机自启动 so 这个也跟着启动?